"""
make_packets.py

Script designed to create fake packets which mimic those which would actually
be generated by devices in the field.

Author: Jordan Bourdeau
Date Created: 6/16/24
"""

import argparse
from datetime import datetime
import os
import struct
from typing import Dict, List

def create_packet(site_number: int, values: Dict[str, int]):
    """
    Create a packet dictionary with specified site_number and values.

    Args:
    - site_number (int): 8-bit integer mapping site locations
    - values (dict): Dictionary of field values where keys are between 1 - 255.

    Returns:
    - dict: Packet dictionary.
    """
    # Generate current timestamp
    timestamp = int(datetime.now().timestamp())

    # Construct packet dictionary
    packet = {
        "id": site_number,
        "time": timestamp,
    }
    
    packet.update(values)
    
    return packet

def encode_packet(packet: Dict):
    """
    Encode packet dictionary as binary data.

    Args:
    - packet (dict): Packet dictionary to encode.

    Returns:
    - bytes: Encoded binary data.
    """
    # Initialize binary data with id and time fields
    data = struct.pack("<BI", packet["id"], packet["time"])

    # Encode each field value (assuming variable size values)
    for key in sorted(packet.keys()):  # Sort keys to ensure consistent order
        if key not in ["id", "time"]:
            value = packet[key]
            data += struct.pack("<B", int(key))  # Encode field identifier as 1-byte integer
            data += struct.pack(f"<I", value)   # Encode value as 4-byte integer (adjust as needed)

    return data.replace(b" ", b"")  # Remove whitespaces (if any)

def decode_packet(data: bytes):
    """
    Decode binary data into a packet dictionary.

    Args:
    - data (bytes): Encoded binary data.

    Returns:
    - dict: Decoded packet dictionary.
    """
    packet = {}
    index = 0

    # Extract id and time fields
    packet["id"], packet["time"] = struct.unpack_from("<BI", data, index)
    index += struct.calcsize("<BI")

    # Decode each field value
    while index < len(data):
        field_key = struct.unpack_from("<B", data, index)[0]
        index += struct.calcsize("<B")
        
        field_value = struct.unpack_from("<I", data, index)[0]
        index += struct.calcsize("<I")
        
        packet[str(field_key)] = field_value

    return packet

def random_packets(num_sites: int, field_sizes: List[int], num_packets: int = None):
    """
    Generator which simulates a random packet stream.
    
    Args:
    - num_sites (int): Number of potential sites to get packets from.
    - field_sizes (List[int]): List of sizes for each field type.
    - num_packets (int, optional): Number of packets to generate. Defaults to 10.

    Yields:
    - Dict: Generated packet as a dictionary.
    """
    packets_remaining = num_packets if num_packets else 10  # Default is 10
    
    while packets_remaining > 0:
        site_number = int.from_bytes(os.urandom(1), byteorder='big') % num_sites
        values = {
            str(field_index): int.from_bytes(os.urandom(field_size), byteorder='big')
            for field_index, field_size in enumerate(field_sizes, start=1)  # Start index from 1
        }
        yield create_packet(site_number, values)
        packets_remaining -= 1
        
def main(num_sites: int, field_sizes: List[int], num_packets: int, output_file: str):
    """
    Main function to generate random packets and save them to an output file.

    Args:
    - num_sites (int): Number of potential sites to get packets from.
    - field_sizes (List[int]): List of sizes for each field type.
    - num_packets (int): Number of packets to generate.
    - output_file (str): Output file path to save binary encoded packets.
    """
    with open(output_file, 'wb') as f:
        for packet in random_packets(num_sites, field_sizes, num_packets):
            encoded_data = encode_packet(packet)
            f.write(encoded_data)
            f.write(b'\n')  # Add a newline between packets for clarity in binary file

if __name__ == "__main__":
    # Set target output file for binary encoded packets
    
    parser = argparse.ArgumentParser(description='Generate fake packets and save them as binary encoded data.')
    parser.add_argument('--num_sites', type=int, default=10, help='Number of potential sites to generate packets from.')
    parser.add_argument('--field_sizes', type=int, nargs='+', default=[1, 4, 4, 4, 1, 2, 4], 
                        help='List of sizes for each field type.')
    parser.add_argument('--num_packets', type=int, default=10, help='Number of packets to generate.')
    parser.add_argument('--output_file', type=str, default='fake_packets.bin', help='Output file for binary encoded packets.')

    args = parser.parse_args()

    main(args.num_sites, args.field_sizes, args.num_packets, args.output_file)